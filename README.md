#singleton-watcher

##Overview
This is a Non-native timer based watcher for any value. It will be useful when the aim is to observe values for which there is no native support so far. For example, if we want to watch height change of a particular DOM element that can be changed from anywhere. Note, if you are sure that You are using inline style/height attribute or changing the class from where the height is affecting then its better use MutationObserver or DOMSubtreeModified. It is recommended to use this watcher when there is no native support for that event delegation. Using this watcher its possible
to watch any objects/array or any primitive value as well.

##Why preferred SingletonWatcher instead of manually starting a timer (interval/timeout)
When you have to watch a value, and you don't have a native support, and you don't know the possible reasons of change as well,you could have start a recursive timeout or interval from your side. But the only different is in that case you need to manipulate the entire life cycle of that.Also if you want to watch multiple values, you will run multiple timers. Instead of that we tried to run a single timer (only when there is atleast 1 item to watch) logically. It provides the flexibility of event proxy object, custom comparator, remove of watcher(s) previously added and so on. We beleive that this logical layers can be written by you as well, but its just a step to reduce those work, and maintain a common library that can be shared across multiple projects, and this repo will be better day by day.

##How to use
As of now singleton-watcher is not an npm repo, we will plan for it. Upto that period you can directly clone and host it with your app and then simply add a script src to the singleton-watcher js file. Once added, you will get a refernce to this lib object as `SingletonWatcher`, and then check the followings

- `SingletonWatcher` comes with mainly 2 methods, `addWatch(itemToWatch, eventCallback or config)` and `removeWatch(watchItemId or itemToWatch)`
- `addWatch` will return a object as response having 2 mandatory fields `status` and `state`, `status` will be true in case of successfully addition of watcher, and `state` is nothing but an integer value, mapped with a Enum object comes under `SingletonWatcher.RESPONSE_STATES`. In case of success another property will come as  `id` as id of the watcher, later it can be used to remove it from the watcher by using  `removeWatcher(id or itemToWatch)` .In case of removal success it will return true otherwise false.
- The first argument of `addWatch` is the item to watch. it can be object/array/or a callback, that evaluates the value, if you want to watch for a primitive value you need to pass a callback that will return the value. also you can use callback for other types of value too.
- If you are passing an object/array, and want to monitor any change on that, then either you can pass a compare callback as a `compare` key of the next argument (`config`) which will take 2 arguments `compare(newVal, oldVal)` and return true if there is no change in the perspective of your compare. Otherwise you need to use underscore.js or any such libraries that contains a deep checking algo of two objects. As of now, we didn't implement any default deep checking algo.
- You cannot pass string or primitive type for watch. As string is immutable and primitives are passed by value, once it is passed to the watcher, what the watcher is pointing to cannot be changed. If you really want to monitor any string value or any primitive value, pass a callback instead which will return string or primitive value.
- If you are passing a callback as the watch item, it will watch the evaluated value of that callback. If you want to specify the object monitor under what your callback will execute (even with the argument lists as well) to evaluate the value dynamically, you can pass it in the property of config (second argument) like `{objectMonitor: <object>, args: <Array>}`. If your callback is returning a object by default it will check for the change by its reference. If you want a deep checking (all nested values), in config argument you can pass  `deep` key as value true. But, be sure if you are passing  `deep` as true then either pass a `compare` key as acompare algo or use underscore or any such libraries having a deep comparing algo, as we don't have an implementation of an default deep checking algo so far.