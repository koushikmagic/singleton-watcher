#singleton-watcher

##Overview
This is a Non-native timer based watcher for any value. It will be usefull when the aim is to observe values for which there is no native support so far. For example if we want to watch height change of a particular DOM element that can be changed from anywhere. Note, If you are sure thatYou are using inline style/height attribute or changing the class from where the height is affecting then its better use MutationObserver or DOMSubtreeModified. Its is recomended to use this watcher when there is no native support for that event delegation. Using this watcher its possble
to watch any objects/array or any primitive value as well.

##Why preferred SingletonWatcher instead of manually start a timer (interval/timeout)
When you have to watch a value, and you don't have a native support, and you don't know the possible reasons of change as well,you could have start a recursive timeout or interval from your side. But the only different is in that case you need to manupulate theentire life cycle of that.and also if you want to watch multiple values, you will run multiple timers. Instead of that we tried to run a single timer (only when there is atleast 1item to watch) logically. and also provide the flexibility of event proxy object, custom comparator, remove of watcher(s) previously added and so on. We beleive that this logical layers can be written by you as well, but its just a step to reduce those work, and maintain a common library that will be shared across multiple projects, and this repo will be better day by day.

##How to use
As of now singleton-watcher is not an npm repo, we will plan for it. Upto that period you can directly clone and host it with your app. and then simple add a script src to the singleton-watcher js file. Once added, you a refernce to this lib object as `SingletonWatcher`, and then check the followings

- `SingletonWatcher` comes with 2 methods, `addWatch(itemToWatch, eventCallback or config)` and `removeWatch(watchItemId or itemToWatch)`
- `addWatch` will return a object as response having 2 mandatory fields `status` and `state`, `status` will be true in case of successfully adding of watcher, and `state` is nothing but an integer value, mapped with a Enum object comes under `SingletonWatcher.RESPONSE_STATES`. In case of success another property will come as  `id` as id of the watcher, later it can be used to remove it from the watcher using  `removeWatcher(id or itemToWatch)` in case of removal success it will return true otherwise false.
- The first argument of `addWatch` is the item to watch. it can be object/array/or a callback, that evaluates the value, if you want to watch for a primitive value you need to pass a callback that will return the value. also you can use callback for other types of value too.
- If you are passing an object/array, and want to monitor any change on that, then either you can pass a compare callback as a `compare` key of the next argument (`config`) that will take 2 argument `compare(newVal, oldVal)` and return true if there is no change in the perspective your compare. Otherwise you need to use underscore.js or such libraries that contains a deep checking algo of two objects. As of now, we didn't implemented any default deep checking algo.
- You cannot pass string or primitive types for watch. as string isimmutable and primitive are pased by value, once its passed to watcher, what watcher is pointing to cannot be changed. if you really want to monitor any string value or any primitive value pass a callback instead.
- If you are passing a callback as a watch item, it will watch the evaluation value of that call back. If you want you can specify the object monitor under what you want to execute with the argumentlists as well, to evaluate the value dynamically you want to watch. If your callback returning a object b default it will check for change by its reference. if you want a deep checking (all nested values), in config argument you can pass  `deep` key as value true. But, be sude if you are passing  `deep` true then either pass a `compare` key as acompare algo or use underscore or such libraries having a deep comparing also, as we don't have an implementation of an dfault deep checking algo so far.